# start of program

addi $r1 $r0 5      # 5
addi $r2 $r2 1      # 1...5
addi $r3 $r0 2      # 2
addi $r4 $r4 1      # counter to how many times before branch is entered
bne $r1 $r2 -4      # loops until $r1 and $r2 are equal
addi $r5 $r5 1      # counter to how many times after branch is entered
sub $r6 $r3 $r1     # -3
muli $r7 $r2 -5     # -25
andi $r8 $r1 6      # 4
ori $r9 $r1 10      # 15
j 14                # should skip next 3 instructions
addi $r10 $r0 100
addi $r11 $r0 100
addi $r12 $r0 100
# should resume here after jump
sll $r13 $r1 2      # 20
srl $r14 $r1 2      # 1
sw $r7 $r0 1024     # M[1024] = -25
add $r15 $r13 $r13  # 40
lw $r16 $r0 1024    # -25 <- M[1024]

# should run in 89 clk cycles (7 + (32 + 10 - 1) * 2)
# 32 actual instructions and 10 NOP instructions due to branching and jumping
# branched 4 times so 4*2 NOP operations + jumped 1 time so 1*2 NOP operations